## 3번째 딥다이브 - Python 코드 흐름 이해하기: 동기, 비동기, 그리고 콜백

### ❓ 힌트
- **Call Stack, Event Loop, Callback Function**
- **실행 컨텍스트(Execution Context), 동기(Synchronous) vs 비동기(Asynchronous)**


1. 코드를 읽을 때 어디서부터 읽기 시작하나요? (첫 번째 줄? `main()` 함수? 맨 아래?)
   - ***읽을 때는 main()함수의 시작점부터 따라가기.***


2. `def my_function():` 이라고 적힌 부분은 "정의"인가요, "실행"인가요?
   - ***"정의"***


3. `my_function()`이라고 적힌 부분은 "정의"인가요, "실행"인가요?
   - ***"실행"***


4. 함수 안에서 다른 함수를 호출하면 실행 순서는 어떻게 되나요?
   - ***"A 실행 → B 호출 및 실행 → C 호출 및 실행 → C 끝 → B 끝 → A 끝" 형태, LIFO (스택 구조)***


5. Python 파일을 처음 실행하면 코드가 어떤 순서로 실행되는가? (위에서 아래로? 함수의 정의와 실행 분리해서 생각하기 + 함수 정의 된건 언제 실행되나?)
   - ***코드 실행 : 위 → 아래***


6. `print("A")` → `some_function()` → `print("B")` 순서로 작성하면 항상 A → 함수 내용 → B 순으로 출력되는가?
   - ***some_function이 동기 실행의 경우 순서대로지만, 비동기식 or 멀티프로세스 실행이면 B가 먼저 출력될 수 있다.***


7. 비동기로 처리될 때 코드의 실행 순서는 어떻게 달라지는가? `async`/`await`가 붙으면 Call Stack에서 무슨 일이 일어나는가?
   - ***await 만나면 → 중단, "콜-스택"에서 빠져나와 "이벤트 루프"에 "나중에 다시 실행할 것"으로 새롭게 등록 ***


8. 콜백(Callback) 함수란 무엇이고, 왜 "나중에 불러줘"라는 패턴이 필요한가?
   - ***직접 호출하는 것이 아닌 "다른 함수에 의해 호출되는 함수", 어떤 작업은 오래 걸리거나 안끝날수도 있는데 멈추지 않고 계속 실행되도록 하기 위해. ***


9. JavaScript의 콜백 지옥(Callback Hell)이 Python에서는 어떻게 해결되었는가?
   - ***콜백 지옥 : 콜백안에 콜백이 계속 중첩되서 코드가 드러워지는 구조, 파이썬은 "async await"를 써서 해결했다. ***
---

### 1. Call Stack (콜스택) -> "자료구조"
<img width="567" height="528" alt="image" src="https://github.com/user-attachments/assets/6aa0d873-658a-486e-9346-3df042fe53af" />


 1) "LIFO" 방식으로 동작한다. "후입선출"
    - 큐 vs ***스택*** (First In First Out vs Last In First Out)
    > 헷갈리면, 랭크 큐 돌리면 먼저 돌린 사람이 게임 먼저 잡히는 걸 생각하십쇼.
    - ***Python의 함수는 기본적으로 스택 방식으로 호출되는 것이 원칙.***
 2) 함수 호출 시 Stack Frame을 생성한다.
    - 어떤 상자 안에 그 함수의 "매개변수", "로컬변수", "반환주소" 등의 정보가 담겨있다고 생각하면 됩니다.
    > 함수가 또다른 함수를 호출(Call) 했다면, 그 상자가 또 위에 LIFO 처럼 올라가는 겁니다. 
 3) 함수 실행 끝나면 생성되었던 Stack Frame이 제거된다.
    - **위에 올려진 애부터 없애야지** 그 밑에 애가 제거 대상이 되는 것.
 
      
### 2. Call Back Function(콜백함수)
 1) 직접 호출하는 것이 아닌 "다른 함수에 의해 호출 당하는 함수"
    - 함수 자체를 파라미터로 전달받고, 호출 당한 함수에서는 전달받은 함수를 호출하는 구조.
<img width="603" height="494" alt="image" src="https://github.com/user-attachments/assets/bd6e61c2-bc8a-4636-94a9-e2e64d0bed6d" />


> print_hello : 콜백 함수 callback_func : 콜백함수를 이용하는 함수, func : 콜백 함수가 들어가는 파라미터
 - callback_func는 자기 일을 하다가 print_hello가 필요해진 시점이 오면 그놈을 호출한다.


### 3. Event Loop 
 1) 모든 비동기식 I/O 프로그램의 핵심. 비동기식 작업 & 콜백 동작을 제어하는 "총 책임 관리자". asyncio 라이브러리 활용
   - 작업 실행의 흐름이 차단되지 않고, 프로그램이 여러 작버을 효율적으로 처리할 수 있는 방식
   - 무한 루프를 돌며 매 루프마다 작업을 하나씩 실행시키는 역할. "싱글 스레드 환경"에서 동작한다.
<img width="613" height="497" alt="image" src="https://github.com/user-attachments/assets/173b86e6-3b87-4f9d-8032-b3fbdb54ed4e" />


- "await"의 진짜 의미: "이 작업 말고 다른 일 할 거 있으면 먼저 처리해도 된다."
> 각 요청이 0.1초 차이라고 가정하면, fetch-data에서 처음 await가 걸리면 fetch-data2로 가고, 두번째 await가 걸리는 것. 여기서 이벤트 루프는 다 불러왔으니까, 불러온 애들 완료되는거 기다렸다가 준비된 애부터 실행하는 것


### 4. Execution Context(실행 컨텍스트)
#### ***지금 이 코드가 어떤 환경에서, 어떤 순서로, 어떤 상태를 가지고 실행되고 있나요?*** 의 정보를 담은 객체
 - 지금 실행 중인 함수는 무엇인가?
 - 이 함수의 전역 변수, 지역 변수는 뭐가 있는가?
 - 이 함수는 어디서 호출되었는가?
 - 끝나면 어디로 돌아가야 하는가?
 - 비동기라면: 멈췄는지, 재개해야 하는지?
 > Python은 프로그램이 시작되고 함수가 호출될 때 이 Execution Context를 생성하고 관리한다. (의식하지 못하지만 매번 사용되고 있는 것)

## Thread?
 - 실제로 동시에 실행되는 흐름. 각 쓰레드는 자기만의 콜 스택을 가지고, 병렬 실행이 가능하다.
 - Async와 비교하면 : Async는 **"단일 쓰레드" 안에서 일종의 멀티태스킹**을 하는 것.


## 참고 자료
[콜스택] : https://www.youtube.com/watch?v=-AzANhKOpHA
